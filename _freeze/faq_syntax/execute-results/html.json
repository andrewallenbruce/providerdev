{
  "hash": "c78b54f6cef02d4694c2790705349a19",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"JSON:API Syntax\"\neditor_options: \n   chunk_output_type: console\n---\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<a href=\"https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/filtering\" class=\"btn btn-outline-secondary\" role=\"button\" target=\"_blank\">\n<i class=\"bi bi-box-arrow-up-right\"></i>\nDrupal JSON:API\n</a>\n```\n\n:::\n:::\n\n## Query Generation\n\n::: {.cell}\n\n```{.r .cell-code}\nformat_syntax <- \\(name, value) {\n  setNames(value, paste0(name, \"[id-\", seq_along(value), \"][condition][value]\"))\n}\n\nformat_syntax(name = \"filter\", value = c(\"GA\", \"NY\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfilter[id-1][condition][value] filter[id-2][condition][value] \n                          \"GA\"                           \"NY\" \n```\n\n\n:::\n\n```{.r .cell-code}\nrequest(\"https://example.com\") |>\n  req_url_query(!!!format_syntax(\"filter\", c(\"GA\", \"NY\")))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_request>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGET\nhttps://example.com/?filter%5Bid-1%5D%5Bcondition%5D%5Bvalue%5D=GA&filter%5Bid-2%5D%5Bcondition%5D%5Bvalue%5D=NY\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: empty\n```\n\n\n:::\n:::\n\n## JSON:API\n\nThe Drupal core [JSON:API module](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module) implements the JSON:API spec for Drupal entities. It provides a zero-configuration required, opinionated, way to allow RESTful CRUD for a Drupal site's content.\n\nIt is closely coupled to Drupal's Entity and Field APIs, response caching, and authentication and authorization systems. Because it follows the shared JSON:API conventions it can help increase productivity and allow you to take advantage of non-Drupal specific tooling.\n\n[Refer to the Drupal documentation](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/filtering) for more information on filtering API requests.\n\n## Filtering\n\n[Collections](https://www.drupal.org/docs/8/modules/json-api/collections-filtering-and-sorting) are listings of resources. When you make an unfiltered request to a collection endpoint like `/jsonapi/node/article`, you'll just get every article that you're allowed to see. Without filters, you can't get only the articles that you want.\n\nThe simplest, most common filter is a **key-value filter**:\n\n```r\n/data?\n   filter[field_1]=value_1&\n   filter[field_2]=value_2\n```\n\nThis matches all resources with `field_1` equal to `\"value_1\"` and `field_2` equal to `\"value_2\"`.\n\n### Conditions\n\nThe fundamental building blocks of JSON:API filters are **Conditions** and **Groups**. \n\n   * __Conditions__ assert that something is `TRUE`\n   * __Groups__ compose sets of conditions\n\nThose sets can be nested to make super fine queries. You can think of a nested set as a tree:\n\n_Conventional representation:_\n\n::: {.cell}\n\n```{.r .cell-code}\nis_A <- \\(x) any(x == \"A\")\nis_B <- \\(x) any(x == \"B\")\nis_C <- \\(x) any(x == \"C\")\nis_D <- \\(x) any(x == \"D\")\nis_E <- \\(x) any(x == \"E\")\n\nx <- c(\"A\", \"B\", \"C\", \"D\", \"E\")\n\nis_A(x[is_B(x) & is_C(x[is_D(x) | is_E(x)])])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- c(\"A\", \"B\", \"C\", \"F\", \"G\")\n\nis_A(x[is_B(x) & is_C(x[is_D(x) | is_E(x)])])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n_Tree representation:_\n\n```r\n   A\n  / \\\n B & C\n    / \\\n   D | E\n```\n\nIn both representations:\n\n   * `D` & `E` are members of `C` in an `OR` group\n   * `B` & `C` are members of `A` in an `AND` group\n\nA **condition** has 3 primary parts: \n\n   1. `[path]`: Dataset **Field**\n   1. `[operator]`: Logical comparison\n   1. `[value]`: Dataset **Row**\n\nIn **JSON:API** syntax, these are formatted as a `key=value` pair to work inside a URL query string:\n\n```r\n/data?\n   filter[fID-1][condition][path]=FIRST_NAME&\n   filter[fID-1][condition][operator]=%3D&\n   filter[fID-1][condition][value]=Janis\n```\n\n> __Note__: `%3D` is the URL-encoded `=` symbol. All operators must be URL-encoded.\n\nNotice the `ID` inside the first set of square brackets. _Every condition or group should have a unique identifier._\n\nLet's add another filter so we only get Janises with a last name that starts with `\"J\"`:\n\n```r\n/data?\n   filter[fID-1][condition][path]=FIRST_NAME&\n   filter[fID-1][condition][operator]=%3D&\n   filter[fID-1][condition][value]=Janis&\n   filter[fID-2][condition][path]=LAST_NAME&\n   filter[fID-2][condition][operator]=STARTS_WITH&\n   filter[fID-2][condition][value]=J\n```\n\n::: callout\n\n## JSON:API Allowed Operators\n\n```r\n= \n<>\n> \n>= \n< \n<=\nSTARTS_WITH \nCONTAINS \nENDS_WITH\nIN \nNOT IN\nBETWEEN \nNOT BETWEEN\nIS NULL \nIS NOT NULL\n```\n\n::: {.cell}\n\n```{.r .cell-code}\nGT <- \\(arg, value) {\n  glue::glue(\n  \"\n  [condition][path]={arg}&\n  [condition][operator]=>&\n  [condition][value]={value}&\n  \")\n}\n\nGT(\"overall_rating\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[condition][path]=overall_rating&\n[condition][operator]=>&\n[condition][value]=3&\n```\n\n\n:::\n\n```{.r .cell-code}\nGTE <- \\(arg, value) {\n  glue::glue(\n  \"filter[fID-1][condition][path]={arg}&\\\\\n  filter[fID-1][condition][operator]=>=&\\\\\n  filter[fID-1][condition][value]={value}\"\n  )\n}\n\nGTE(\"overall_rating\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfilter[fID-1][condition][path]=overall_rating&filter[fID-1][condition][operator]=>=&filter[fID-1][condition][value]=3\n```\n\n\n:::\n\n```{.r .cell-code}\ntest_url <- glue::as_glue(\"https://data.cms.gov/data-api/v1/dataset/datad10d792e-ea6e-4145-8512-34efbc1be04b/data?size=10&offset=0&\")\n\ntest_url <- test_url + GTE(\"overall_rating\", 3)\n\ncurl::curl_parse_url(test_url)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$url\n[1] \"https://data.cms.gov/data-api/v1/dataset/datad10d792e-ea6e-4145-8512-34efbc1be04b/data?size=10&offset=0&filter[fID-1][condition][path]=overall_rating&filter[fID-1][condition][operator]=>=&filter[fID-1][condition][value]=3\"\n\n$scheme\n[1] \"https\"\n\n$host\n[1] \"data.cms.gov\"\n\n$port\nNULL\n\n$path\n[1] \"/data-api/v1/dataset/datad10d792e-ea6e-4145-8512-34efbc1be04b/data\"\n\n$query\n[1] \"size=10&offset=0&filter[fID-1][condition][path]=overall_rating&filter[fID-1][condition][operator]=>=&filter[fID-1][condition][value]=3\"\n\n$fragment\nNULL\n\n$user\nNULL\n\n$password\nNULL\n\n$params\n                              size                             offset \n                              \"10\"                                \"0\" \n    filter[fID-1][condition][path] filter[fID-1][condition][operator] \n                  \"overall_rating\"                                \">\" \n   filter[fID-1][condition][value] \n                               \"3\" \n```\n\n\n:::\n:::\n\n\n::: \n\n### Groups\n\nA **group** is a set of conditions joined by a **conjunction**, either `AND` or `OR`. Let's say we want to find all users with a last name that starts with \"J\" and have either the first name \"Janis\" or \"Joan\". To do that, we add a group:\n\n```r\n/data?\n   filter[gID-1][group][conjunction]=OR\n```\n\nThen, we need assign filters to that new group. To do that, we add a `memberOf` key. Every condition and group can have a `memberOf` key. \n\n```r\n/data?\n   filter[gID-1][group][conjunction]=OR&\n   filter[fID-1][condition][path]=first_name&\n   filter[fID-1][condition][operator]=%3D&\n   filter[fID-1][condition][value]=Janis&\n   filter[fID-1][condition][memberOf]=gID-1&\n   filter[fID-2][condition][path]=first_name&\n   filter[fID-2][condition][operator]=%3D&\n   filter[fID-2][condition][value]=Joan&\n   filter[fID-2][condition][memberOf]=gID-1&\n   filter[fID-3][condition][path]=last_name&\n   filter[fID-3][condition][operator]=STARTS_WITH&\n   filter[fID-3][condition][value]=J\n```\n\n> __Note__: Groups can have a `memberOf` key just like conditions, which means you can have groups of groups. Every filter without a `memberOf` key is assumed to be part of a `root` group with a conjunction of `AND`.\n\nDoes that look familiar? It should, we saw it above as a tree:\n\n```r\n   A         A = root & g1\n  / \\\n /   \\       B = f3\nB  &  C      C = g1\n     / \\\n    /   \\    D = f1\n   D  |  E   E = f2\n```\n\n### Paths\n\nPaths provide a way to filter based on relationship values. Up to this point, we've just been filtering by the hypothetical `first_name` and `last_name`. Suppose we want to filter by the name of a user's career, where career types are stored as a separate resource. We could add a filter like this:\n\n```r\n/data?\n   filter[career][condition][path]=field_career.name&\n   filter[career][condition][operator]=%3D&\n   filter[career][condition][value]=DOCTOR\n```\n\nPaths use a \"dot notation\" to traverse relationships. If a resource has a relationship, you can add a filter against it by concatenating the relationship field name and the relationship's field name with a `.` (dot). You can even filter by relationships of relationships (and so on) just by adding more field names and dots.\n\nYou can filter on a specific index of a relationship by putting a non-negative integer in the path. So the path `some_relationship.1.some_attribute` would only filter by the 2nd related resource.\n\n> Tip: You can filter by sub-properties of a field. For example, a path like `field_phone.country_code` will work even though `field_phone` isn't a relationship.\n\nWhen filtering against configuration properties, you can use an asterisk (`*`) to stand-in for any portion of a path. \n\nFor example, \n\n```r\n/api\n/field_config\n/field_config?\n   filter[dependencies.config.*]=comment.type.comment\n```\n\nwould match all field configs in which `[attributes][dependencies][config]` (an indexed array) contains the value `\"comment.type.comment\"`.\n\n### Shortcuts\n\nWhen the operator is `=`, you don't have to include it:\n```r\n/data?\n   filter[fID-1][condition][path]=FIRST_NAME&\n   filter[fID-1][condition][operator]=%3D&\n   filter[fID-1][condition][value]=Janis\n```\n_becomes_\n```r\n/data?\n   filter[fID-1][condition][path]=FIRST_NAME&\n   filter[fID-1][condition][value]=Janis\n```\nWhen the operator is `=` and you don't need to filter by the same field twice, the path can be the identifier:\n\n```r\n/data?\n   filter[FIRST_NAME][value]=Janis\n```\nReduce the simplest equality checks down to a _key-value_ form:\n\n```r\n/data?\n   filter[FIRST_NAME]=Janis\n```\n\n### Filters and Access Control\n\nFirst, a warning: don't make the mistake of confusing filters for access control. Just because you've written a filter to remove something that a user shouldn't be able to see, doesn't mean it's not accessible. **Always perform access checks on the backend.**\n\nWith that big caveat, let's talk about using filters to complement access control. To improve performance, you should filter out what your users will not be able to see. The most frequent support request in the JSON:API issue queues can be solved by this one simple trick! If you know your users cannot see unpublished content, add the following filter:\n\n```r\n/data?\n   filter[status][value]=1\n```\n\nUsing this method, you'll lower the number of unnecessary requests that you need to make. **That's because JSON:API doesn't return data for resources to which a user doesn't have access.** You can see which resources may have been affected by inspecting the meta.errors section of JSON:API document. So, do your best to filter out inaccessible resources ahead of time.\n\n## Examples\n\n### Exact Match on Column\n\n```r\n/data?\n   filter[PROVIDER_TYPE_DESC]=PRACTITIONER - GENERAL PRACTICE\n```\n\n### CONTAINS \n\nSearch on One Column\n\n```r\n/data?\n   filter[fID-1][condition][path]=PROVIDER_TYPE_DESC&\n   filter[fID-1][condition][operator]=CONTAINS&\n   filter[fID-1][condition][value]=SUPPLIER\n```\n\n### CONTAINS & EQUALS \n\nCombination Search on Two Columns\n\n```r\n/data?\n   filter[fID-1][condition][path]=PROVIDER_TYPE_DESC&\n   filter[fID-1][condition][operator]=CONTAINS&\n   filter[fID-1][condition][value]=PRACTITIONER&\n   filter[fID-2][condition][path]=STATE_CD&\n   filter[fID-2][condition][operator]=%3D&\n   filter[fID-2][condition][value]=MD\n```\n\n### EQUALS Simplified\n\nThis example is an equals filter searching the Accountable Care Organizations 2021 dataset for a single ID.\n\n```r\n/data?\n   filter[fID-1][condition][path]=aco_id&\n   filter[fID-1][condition][operator]=%3D&\n   filter[fID-1][condition][value]=A4807\n```\n\nAn equals filter can be simplified like this.\n\n```r\n/data?\n   filter[aco_id]=A4807\n```\n### Keyword\n\nThe keyword search will look for matching words in every column. This example will check for \"Alex\" in the Order and Referring dataset. Notice that it finds matches on both the first and last name fields.\n\n```r\n/data?\n   keyword=Alex\n```\n\n### Multiple Conditions at Once\n\nThis search returns results from the Medicare Fee-For-Service Public Provider Enrollment dataset where the provider specialty is \"PRACTITIONER - OPTOMETRY\" and the location is Virginia.\n\n```r\n/data?&\n   filter[ROOT][group][conjunction]=AND&\n   filter[GID-1][group][conjunction]=AND&\n   filter[GID-1][group][memberOf]=ROOT&\n   filter[FID-1][condition][path]=PROVIDER_TYPE_DESC&\n   filter[FID-1][condition][operator]=%3D&\n   filter[FID-1][condition][value]=PRACTITIONER - OPTOMETRY&\n   filter[FID-1][condition][memberOf]=GID-1&\n   filter[FID-2][condition][path]=STATE_CD&\n   filter[FID-2][condition][operator]=%3D&\n   filter[FID-2][condition][value]=VA&\n   filter[FID-2][condition][memberOf]=GID-1\n```\n\n### IN\n\nThis search returns results from the Opioid Treatment Program Providers dataset where the provider is located from MD, MI, or VA with the results sorted by NPI.\n\n```r\n/data?\n   filter[condition][path]=STATE&\n   filter[condition][operator]=IN&\n   filter[condition][value][]=MI&\n   filter[condition][value][]=VA&\n   filter[condition][value][]=MD&\n   sort=NPI\n```\n\n**Note About Empty Brackets:**\n\nWhen utilizing square brackets for multiple values filters, *do not just use empty square brackets for a new value.*\nWhile these work when typed into the URL, Guzzle and other HTTP clients will only create one value, as the array key will be seen to be the same and override the previous value. **It is better to use an index to create unique array elements.**\n\nNote the two square brackets added behind the value to make it into an array:\n\n```r\n/data?\n   filter[fID-1][condition][path]=STATE&\n   filter[fID-1][condition][operator]=IN&\n   filter[fID-1][condition][value][1]=MI&\n   filter[fID-1][condition][value][2]=VA&\n   filter[fID-1][condition][value][3]=MA\n```\n\n\n### Sort Results\n\nUse the `sort` query parameter to specify which column the results should be sorted by:\n\n```r\nLowest first:\n\n/data?\n   sort=NPI\n   \nHighest first:\n\n/data?\n   sort=-NPI\n```\n\n### Subset Columns\n\nAdd a comma-separated string of column names to the `column` query parameter to limit the columns returned:\n\n```r\n/data?\n   column=NPI,FIRST_NAME,LAST_NAME\n```\n\n### Only Published Nodes\n\nA very common scenario is to only load the nodes that are published. This is a very easy filter to add.\n\n```r\nSHORT\n   filter[status][value]=1\n\nNORMAL\n   filter[fID-1][condition][path]=status\n   filter[fID-1][condition][value]=1\n```\n\n### Nodes by Value of Entity Reference\n\nA common strategy is to filter content by a entity reference.\n\n```r\nSHORT\n   filter[uid.id][value]=BB09E2CD-9487-44BC-B219-3DC03D6820CD\n\nNORMAL\n   filter[fID-1][condition][path]=uid.id\n   filter[fID-1][condition][value]=BB09E2CD-9487-44BC-B219-3DC03D6820CD\n```\n\nTo fully comply with the JSON API specification, while Drupal internally uses the `uuid` property, __JSON:API__ uses `id` instead.\n\nSince Drupal 9.3 it is possible to filter on `target_id` also instead of only filtering by `uuid` property.\n\n\n```r\nSHORT\n   filter[field_tags.meta.drupal_internal__target_id]=1\n\nNORMAL\n   filter[fID-1][condition][path]=field_tags.meta.drupal_internal__target_id\n   filter[fID-1][condition][value]=1\n```\n\n### Nested Filters\n\nIt's possible to filter on fields from referenced entities like the user, taxonomy fields or any entity reference field. You can do this easily but just using the the following notation. reference_field.nested_field. In this example the reference field is uid for the user and name which is a field of the user entity.\n\n```r\nSHORT\n   filter[uid.name][value]=admin\n\nNORMAL\n   filter[fID-1][condition][path]=uid.name\n   filter[fID-1][condition][value]=admin\n```\n\n### Filtering with Arrays\n\nYou can give multiple values to a filter for it to search in. Next to the field and value keys you can add an operator to your condition. \n\nUsually it's `\"=\"` but you can also use `\"IN\"`, `\"NOT IN\"`, `\">\"`, `\"<\"`, `\"<>\"`, `BETWEEN`\".\n\nFor this example we're going to use the `\"IN\"` operator. Note that I added two square brackets behind the value to make it into an array.\n\n```r\nNORMAL\n   filter[fID-1][condition][path]=uid.name\n   filter[fID-1][condition][operator]=IN\n   filter[fID-1][condition][value][1]=admin\n   filter[fID-1][condition][value][2]=john\n```\n\n### Grouping Filters\n\nNow let's combine some of the examples above and create the following scenario.\nWHERE user.name = admin AND node.status = 1:\n\n```r\nfilter[and-group][group][conjunction]=AND\nfilter[name-filter][condition][path]=uid.name\nfilter[name-filter][condition][value]=admin\nfilter[name-filter][condition][memberOf]=and-group\nfilter[status-filter][condition][path]=status\nfilter[status-filter][condition][value]=1\nfilter[status-filter][condition][memberOf]=and-group\n```\n\nYou don't really have to add the and-group but I find that a bit easier usually.\n\n### Grouping Grouped Filters\n\nLike mentioned in the grouping section, you can put groups into other groups.\nWHERE (user.name = admin) AND (node.sticky = 1 OR node.promoted = 1)\n\nTo do this we put sticky and promoted into a group with conjunction OR. Create a group with conjunction AND and put\nthe admin filter, and the promoted/sticky OR group into that.\n\n```r\n# Create an AND and an OR GROUP\nfilter[and-group][group][conjunction]=AND\nfilter[or-group][group][conjunction]=OR\n\n# Put the OR group into the AND GROUP\nfilter[or-group][group][memberOf]=and-group\n\n# Create the admin filter and put it in the AND GROUP\nfilter[admin-filter][condition][path]=uid.name\nfilter[admin-filter][condition][value]=admin\nfilter[admin-filter][condition][memberOf]=and-group\n\n# Create the sticky filter and put it in the OR GROUP\nfilter[sticky-filter][condition][path]=sticky\nfilter[sticky-filter][condition][value]=1\nfilter[sticky-filter][condition][memberOf]=or-group\n\n# Create the promoted filter and put it in the OR GROUP\nfilter[promote-filter][condition][path]=promote\nfilter[promote-filter][condition][value]=1\nfilter[promote-filter][condition][memberOf]=or-group\n```\n\n### Filter for nodes where 'title' CONTAINS \"Foo\"\n\n```r\nSHORT\nfilter[title][operator]=CONTAINS&filter[title][value]=Foo\n\nNORMAL\nfilter[title-filter][condition][path]=title\nfilter[title-filter][condition][operator]=CONTAINS\nfilter[title-filter][condition][value]=Foo\n```\n\n### Filter by non-standard complex fields (e.g. addressfield)\n\n```r\nFILTER BY LOCALITY\nfilter[field_address][condition][path]=field_address.locality\nfilter[field_address][condition][value]=Mordor\n\nFILTER BY ADDRESS LINE\nfilter[address][condition][path]=field_address.address_line1\nfilter[address][condition][value]=Rings Street\n```\n\n### Filtering on Taxonomy term values (e.g. tags)\n\nFor filtering you'll need to use the machine name of the vocabulary and the field which is present on your node.\n\n```r\nfilter[taxonomy_term--tags][condition][path]=field_tags.name\nfilter[taxonomy_term--tags][condition][operator]=IN\nfilter[taxonomy_term--tags][condition][value][]=tagname\n```\n\n### Filtering on Date (Date only, no time)\n\nDates are filterable. Pass a time string that adheres to the ISO-8601 format.\n\nThis example is for a Date field that is set to be date only (no time).\n\n```r\nfilter[datefilter][condition][path]=field_test_date\nfilter[datefilter][condition][operator]=%3D\nfilter[datefilter][condition][value]=2019-06-27\n```\n\nThis example is for a Date field that supports date and time.\n\n```r\nfilter[datefilter][condition][path]=field_test_date\nfilter[datefilter][condition][operator]=%3D\nfilter[datefilter][condition][value]=2019-06-27T16%3A00%3A00\n```\n\nNote that timestamp fields (like created or changed) currently must use a timestamp for filtering:\n\n```r\nfilter[recent][condition][path]=created\nfilter[recent][condition][operator]=%3D\nfilter[recent][condition][value]=1591627496\n```\n\n###  Filtering on empty array fields\n\nThis example is for a Checkboxes/Radio buttons field with no value selected. Consider you have a field that is a checkbox. You would like to get all nodes that do not have that value checked. When checked, the JSON API returns an array:\n\n```r\n\"my_field\":[\"checked\"]\n```\n\nWhen unchecked, the JSON API returns an empty array:\n\n```r\n\"my_field\": [] \n```\n\nIf you would like to get all fields that are unchecked, you must use the IS NULL on the array as follows (without a value):\n\n```r\nfilter[my-filter][condition][path]=my_field\nfilter[my-filter][condition][operator]=IS NULL\n```\n\n--------------------------------------------------------------------------------\n\n## Building Queries\n\n   1. Select Dataset/Method\n   1. Build JSON Query\n   1. Retrieve Number of Results\n   1. Build Offset Sequence\n   1. Build Request\n\n```r\ncatalog:        main_catalog\n  format:       API\n  description:  latest\n  title:        Medicare Fee-For-Service Public Provider Enrollment\n  accessURL:    \"\"\n```\n\n```{.yaml}\nscheme:   https://\nhostname: data.cms.gov/\npath:\n          head:       data-api/v1/dataset/\n          identifier: 9887a515-7552-4693-bf58-735c77af46d7/\n          tail:       data?\n          nobs:       data/stats?\nquery:\n          filter:     1\n          path:       PROVIDER_TYPE_DESC\n          operator:   =\n          value:      PRACTITIONER - GENERAL PRACTICE\n          call:       filter[PROVIDER_TYPE_DESC]=PRACTITIONER - GENERAL PRACTICE\n```\n",
    "supporting": [
      "faq_syntax_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}